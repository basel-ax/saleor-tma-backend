package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.87

import (
	"context"
	"fmt"

	"saleor-tma-backend/graph/model"
	"saleor-tma-backend/internal/app/tma"
	"saleor-tma-backend/internal/telegram"
)

// PlaceOrder is the resolver for the placeOrder field.
func (r *mutationResolver) PlaceOrder(ctx context.Context, input model.PlaceOrderInput) (*model.PlaceOrderPayload, error) {
	auth, ok := telegram.FromContext(ctx)
	if !ok {
		return nil, ErrUnauthenticated
	}

	items := make([]tma.CartItem, 0, len(input.Items))
	for _, it := range input.Items {
		items = append(items, tma.CartItem{
			DishID:   it.DishID,
			Quantity: int(it.Quantity),
		})
	}

	var loc *tma.DeliveryLocation
	if input.DeliveryLocation != nil {
		loc = &tma.DeliveryLocation{
			Lat: input.DeliveryLocation.Lat,
			Lng: input.DeliveryLocation.Lng,
		}
	}

	googleURL := ""
	if input.GoogleMapsURL != nil {
		googleURL = *input.GoogleMapsURL
	}
	comment := ""
	if input.Comment != nil {
		comment = *input.Comment
	}

	res, err := r.TMA.PlaceOrder(ctx, auth.User.ID, tma.PlaceOrderInput{
		RestaurantID:     input.RestaurantID,
		Items:            items,
		DeliveryLocation: loc,
		GoogleMapsURL:    googleURL,
		Comment:          comment,
	})
	if err != nil {
		return nil, err
	}

	return &model.PlaceOrderPayload{
		OrderID: res.OrderID,
		Status:  res.Status,
	}, nil
}

// Restaurants is the resolver for the restaurants field.
func (r *queryResolver) Restaurants(ctx context.Context, search *string) ([]*model.Restaurant, error) {
	_, ok := telegram.FromContext(ctx)
	if !ok {
		return nil, ErrUnauthenticated
	}

	term := ""
	if search != nil {
		term = *search
	}

	rs, err := r.TMA.ListRestaurants(ctx, term)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Restaurant, 0, len(rs))
	for _, r := range rs {
		rCopy := r
		desc := stringPtrOrNil(rCopy.Description)
		img := stringPtrOrNil(rCopy.ImageURL)
		out = append(out, &model.Restaurant{
			ID:          rCopy.ID,
			Name:        rCopy.Name,
			Description: desc,
			ImageURL:    img,
			Tags:        rCopy.Tags,
		})
	}
	return out, nil
}

// RestaurantCategories is the resolver for the restaurantCategories field.
func (r *queryResolver) RestaurantCategories(ctx context.Context, restaurantID string) ([]*model.Category, error) {
	_, ok := telegram.FromContext(ctx)
	if !ok {
		return nil, ErrUnauthenticated
	}

	cs, err := r.TMA.ListCategories(ctx, restaurantID)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Category, 0, len(cs))
	for _, c := range cs {
		cCopy := c
		desc := stringPtrOrNil(cCopy.Description)
		img := stringPtrOrNil(cCopy.ImageURL)
		out = append(out, &model.Category{
			ID:           cCopy.ID,
			RestaurantID: cCopy.RestaurantID,
			Name:         cCopy.Name,
			Description:  desc,
			ImageURL:     img,
		})
	}
	return out, nil
}

// CategoryDishes is the resolver for the categoryDishes field.
func (r *queryResolver) CategoryDishes(ctx context.Context, restaurantID string, categoryID string) ([]*model.Dish, error) {
	_, ok := telegram.FromContext(ctx)
	if !ok {
		return nil, ErrUnauthenticated
	}

	ds, err := r.TMA.ListDishes(ctx, restaurantID, categoryID)
	if err != nil {
		return nil, err
	}

	out := make([]*model.Dish, 0, len(ds))
	for _, d := range ds {
		dCopy := d
		out = append(out, &model.Dish{
			ID:           dCopy.ID,
			ProductID:    dCopy.ProductID,
			RestaurantID: dCopy.RestaurantID,
			CategoryID:   dCopy.CategoryID,
			Name:         dCopy.Name,
			Description:  dCopy.Description,
			ImageURL:     dCopy.ImageURL,
			Price: &model.Money{
				Amount:   dCopy.Price.Amount,
				Currency: dCopy.Price.Currency,
			},
		})
	}
	return out, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

var ErrUnauthenticated = fmt.Errorf("unauthenticated")

func stringPtrOrNil(s string) *string {
	if s == "" {
		return nil
	}
	return &s
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	panic(fmt.Errorf("not implemented: CreateTodo - createTodo"))
}
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	panic(fmt.Errorf("not implemented: Todos - todos"))
}
*/
