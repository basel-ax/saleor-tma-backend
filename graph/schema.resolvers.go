package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.87

import (
	"context"
	"saleor-tma-backend/graph/model"
	"saleor-tma-backend/internal/app/tma"
	"saleor-tma-backend/internal/telegram"
)

// PlaceOrder is the resolver for the placeOrder field.
func (r *mutationResolver) PlaceOrder(ctx context.Context, input model.PlaceOrderInput) (*model.PlaceOrderPayload, error) {
	auth, ok := telegram.FromContext(ctx)
	if !ok {
		return nil, ErrUnauthenticated
	}

	items := make([]tma.CartItem, 0, len(input.Items))
	for _, it := range input.Items {
		items = append(items, tma.CartItem{
			DishID:   it.DishID,
			Quantity: int(it.Quantity),
		})
	}

	var loc *tma.DeliveryLocation
	if input.DeliveryLocation != nil {
		loc = &tma.DeliveryLocation{
			Lat: input.DeliveryLocation.Lat,
			Lng: input.DeliveryLocation.Lng,
		}
	}

	googleURL := ""
	if input.GoogleMapsURL != nil {
		googleURL = *input.GoogleMapsURL
	}
	comment := ""
	if input.Comment != nil {
		comment = *input.Comment
	}

	res, err := r.TMA.PlaceOrder(ctx, auth.User.ID, tma.PlaceOrderInput{
		RestaurantID:     input.RestaurantID,
		Items:            items,
		DeliveryLocation: loc,
		GoogleMapsURL:    googleURL,
		Comment:          comment,
	})
	if err != nil {
		return nil, err
	}

	return &model.PlaceOrderPayload{
		OrderID: res.OrderID,
		Status:  res.Status,
	}, nil
}

// Restaurants is the resolver for the restaurants field.
func (r *queryResolver) Restaurants(ctx context.Context, search *string) ([]*model.Restaurant, error) {
	_, ok := telegram.FromContext(ctx)
	if !ok {
		return nil, ErrUnauthenticated
	}

	term := ""
	if search != nil {
		term = *search
	}

	rs, err := r.TMA.ListRestaurants(ctx, term)
	if err != nil {
		return nil, err
	}

	out := make([]*model.Restaurant, 0, len(rs))
	for _, r := range rs {
		out = append(out, &model.Restaurant{
			ID:          r.ID,
			Name:        r.Name,
			Description: stringPtrOrNil(r.Description),
			ImageURL:    stringPtrOrNil(r.ImageURL),
			Tags:        r.Tags,
		})
	}
	return out, nil
}

// RestaurantCategories is the resolver for the restaurantCategories field.
func (r *queryResolver) RestaurantCategories(ctx context.Context, restaurantID string) ([]*model.Category, error) {
	_, ok := telegram.FromContext(ctx)
	if !ok {
		return nil, ErrUnauthenticated
	}

	cs, err := r.TMA.ListCategories(ctx, restaurantID)
	if err != nil {
		return nil, err
	}

	out := make([]*model.Category, 0, len(cs))
	for _, c := range cs {
		out = append(out, &model.Category{
			ID:           c.ID,
			RestaurantID: c.RestaurantID,
			Name:         c.Name,
			Description:  stringPtrOrNil(c.Description),
			ImageURL:     stringPtrOrNil(c.ImageURL),
		})
	}
	return out, nil
}

// CategoryDishes is the resolver for the categoryDishes field.
func (r *queryResolver) CategoryDishes(ctx context.Context, restaurantID string, categoryID string) ([]*model.Dish, error) {
	_, ok := telegram.FromContext(ctx)
	if !ok {
		return nil, ErrUnauthenticated
	}

	ds, err := r.TMA.ListDishes(ctx, restaurantID, categoryID)
	if err != nil {
		return nil, err
	}

	out := make([]*model.Dish, 0, len(ds))
	for _, d := range ds {
		out = append(out, &model.Dish{
			ID:           d.ID,
			ProductID:    d.ProductID,
			RestaurantID: d.RestaurantID,
			CategoryID:   d.CategoryID,
			Name:         d.Name,
			Description:  d.Description,
			ImageURL:     d.ImageURL,
			Price: &model.Money{
				Amount:   d.Price.Amount,
				Currency: d.Price.Currency,
			},
		})
	}
	return out, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
